// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import { Layer } from '@deck.gl/core';
import GL from 'luma.gl/constants';
import { Model, CubeGeometry, fp64 } from 'luma.gl';
const fp64LowPart = fp64.fp64LowPart;
import vs from './gpu-grid-cell-layer-vertex.glsl';
import fs from './gpu-grid-cell-layer-fragment.glsl';
const DEFAULT_MINCOLOR = [0, 0, 0, 255];
const DEFAULT_MAXCOLOR = [0, 255, 0, 255];
const AGGREGATION_DATA_UBO_INDEX = 0;
const defaultProps = {
  cellSize: {
    type: 'number',
    min: 0,
    max: 20,
    value: 20
  },
  coverage: {
    type: 'number',
    min: 0,
    max: 1,
    value: 1
  },
  elevationScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  extruded: true,
  fp64: false,
  pickable: false,
  // TODO: add picking support (read from aggregated texture)
  minColor: DEFAULT_MINCOLOR,
  maxColor: DEFAULT_MAXCOLOR,
  lightSettings: {}
};
export default class GPUGridCellLayer extends Layer {
  getShaders() {
    return {
      vs,
      fs,
      modules: ['project32', 'lighting', 'picking', 'fp64']
    };
  }

  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceCounts: {
        size: 4,
        update: this.calculateInstanceCounts,
        noAlloc: true
      }
    });
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    super.updateState({
      props,
      oldProps,
      changeFlags
    }); // Re-generate model if geometry changed

    if (props.fp64 !== oldProps.fp64) {
      const gl = this.context.gl;

      if (this.state.model) {
        this.state.model.delete();
      }

      const model = this._getModel(gl);

      this._setupUniformBuffer(model);

      this.setState({
        model
      });
      this.state.attributeManager.invalidate('instanceCounts');
    }

    if (props.countsBuffer !== oldProps.countsBuffer) {
      this.state.attributeManager.invalidate('instanceCounts');
    }
  }

  _getModel(gl) {
    return new Model(gl, Object.assign({}, this.getShaders(), {
      id: this.props.id,
      geometry: new CubeGeometry(),
      isInstanced: true,
      shaderCache: this.context.shaderCache
    }));
  }

  draw({
    uniforms
  }) {
    const _this$props = this.props,
          cellSize = _this$props.cellSize,
          extruded = _this$props.extruded,
          elevationScale = _this$props.elevationScale,
          coverage = _this$props.coverage,
          gridSize = _this$props.gridSize,
          gridOrigin = _this$props.gridOrigin,
          gridOffset = _this$props.gridOffset,
          minColor = _this$props.minColor,
          maxColor = _this$props.maxColor,
          maxCountBuffer = _this$props.maxCountBuffer;
    const gridOriginLow = [fp64LowPart(gridOrigin[0]), fp64LowPart(gridOrigin[1])];
    const gridOffsetLow = [fp64LowPart(gridOffset[0]), fp64LowPart(gridOffset[1])];
    maxCountBuffer.bind({
      target: GL.UNIFORM_BUFFER,
      index: AGGREGATION_DATA_UBO_INDEX
    });
    this.state.model.render(Object.assign({}, uniforms, {
      cellSize,
      extruded,
      elevationScale,
      coverage,
      gridSize,
      gridOrigin,
      gridOriginLow,
      gridOffset,
      gridOffsetLow,
      minColor,
      maxColor
    }));
    maxCountBuffer.unbind({
      target: GL.UNIFORM_BUFFER,
      index: AGGREGATION_DATA_UBO_INDEX
    });
  }

  calculateInstanceCounts(attribute) {
    const countsBuffer = this.props.countsBuffer;
    attribute.update({
      buffer: countsBuffer
    });
  }

  _setupUniformBuffer(model) {
    const gl = this.context.gl;
    const programHandle = model.program.handle;
    const uniformBlockIndex = gl.getUniformBlockIndex(programHandle, 'AggregationData');
    gl.uniformBlockBinding(programHandle, uniformBlockIndex, AGGREGATION_DATA_UBO_INDEX);
  }

}
GPUGridCellLayer.layerName = 'GridCellLayer';
GPUGridCellLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ncHUtZ3JpZC1sYXllci9ncHUtZ3JpZC1jZWxsLWxheWVyLmpzIl0sIm5hbWVzIjpbIkxheWVyIiwiR0wiLCJNb2RlbCIsIkN1YmVHZW9tZXRyeSIsImZwNjQiLCJmcDY0TG93UGFydCIsInZzIiwiZnMiLCJERUZBVUxUX01JTkNPTE9SIiwiREVGQVVMVF9NQVhDT0xPUiIsIkFHR1JFR0FUSU9OX0RBVEFfVUJPX0lOREVYIiwiZGVmYXVsdFByb3BzIiwiY2VsbFNpemUiLCJ0eXBlIiwibWluIiwibWF4IiwidmFsdWUiLCJjb3ZlcmFnZSIsImVsZXZhdGlvblNjYWxlIiwiZXh0cnVkZWQiLCJwaWNrYWJsZSIsIm1pbkNvbG9yIiwibWF4Q29sb3IiLCJsaWdodFNldHRpbmdzIiwiR1BVR3JpZENlbGxMYXllciIsImdldFNoYWRlcnMiLCJtb2R1bGVzIiwiaW5pdGlhbGl6ZVN0YXRlIiwiYXR0cmlidXRlTWFuYWdlciIsImdldEF0dHJpYnV0ZU1hbmFnZXIiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZUNvdW50cyIsInNpemUiLCJ1cGRhdGUiLCJjYWxjdWxhdGVJbnN0YW5jZUNvdW50cyIsIm5vQWxsb2MiLCJ1cGRhdGVTdGF0ZSIsInByb3BzIiwib2xkUHJvcHMiLCJjaGFuZ2VGbGFncyIsImdsIiwiY29udGV4dCIsInN0YXRlIiwibW9kZWwiLCJkZWxldGUiLCJfZ2V0TW9kZWwiLCJfc2V0dXBVbmlmb3JtQnVmZmVyIiwic2V0U3RhdGUiLCJpbnZhbGlkYXRlIiwiY291bnRzQnVmZmVyIiwiT2JqZWN0IiwiYXNzaWduIiwiaWQiLCJnZW9tZXRyeSIsImlzSW5zdGFuY2VkIiwic2hhZGVyQ2FjaGUiLCJkcmF3IiwidW5pZm9ybXMiLCJncmlkU2l6ZSIsImdyaWRPcmlnaW4iLCJncmlkT2Zmc2V0IiwibWF4Q291bnRCdWZmZXIiLCJncmlkT3JpZ2luTG93IiwiZ3JpZE9mZnNldExvdyIsImJpbmQiLCJ0YXJnZXQiLCJVTklGT1JNX0JVRkZFUiIsImluZGV4IiwicmVuZGVyIiwidW5iaW5kIiwiYXR0cmlidXRlIiwiYnVmZmVyIiwicHJvZ3JhbUhhbmRsZSIsInByb2dyYW0iLCJoYW5kbGUiLCJ1bmlmb3JtQmxvY2tJbmRleCIsImdldFVuaWZvcm1CbG9ja0luZGV4IiwidW5pZm9ybUJsb2NrQmluZGluZyIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxTQUFRQSxLQUFSLFFBQW9CLGVBQXBCO0FBQ0EsT0FBT0MsRUFBUCxNQUFlLG1CQUFmO0FBQ0EsU0FBUUMsS0FBUixFQUFlQyxZQUFmLEVBQTZCQyxJQUE3QixRQUF3QyxTQUF4QztNQUNPQyxXLEdBQWVELEksQ0FBZkMsVztBQUVQLE9BQU9DLEVBQVAsTUFBZSxtQ0FBZjtBQUNBLE9BQU9DLEVBQVAsTUFBZSxxQ0FBZjtBQUVBLE1BQU1DLG1CQUFtQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLEdBQVYsQ0FBekI7QUFDQSxNQUFNQyxtQkFBbUIsQ0FBQyxDQUFELEVBQUksR0FBSixFQUFTLENBQVQsRUFBWSxHQUFaLENBQXpCO0FBQ0EsTUFBTUMsNkJBQTZCLENBQW5DO0FBRUEsTUFBTUMsZUFBZTtBQUNuQkMsWUFBVTtBQUFDQyxVQUFNLFFBQVA7QUFBaUJDLFNBQUssQ0FBdEI7QUFBeUJDLFNBQUssRUFBOUI7QUFBa0NDLFdBQU87QUFBekMsR0FEUztBQUVuQkMsWUFBVTtBQUFDSixVQUFNLFFBQVA7QUFBaUJDLFNBQUssQ0FBdEI7QUFBeUJDLFNBQUssQ0FBOUI7QUFBaUNDLFdBQU87QUFBeEMsR0FGUztBQUduQkUsa0JBQWdCO0FBQUNMLFVBQU0sUUFBUDtBQUFpQkMsU0FBSyxDQUF0QjtBQUF5QkUsV0FBTztBQUFoQyxHQUhHO0FBSW5CRyxZQUFVLElBSlM7QUFLbkJmLFFBQU0sS0FM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MTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xheWVyfSBmcm9tICdAZGVjay5nbC9jb3JlJztcbmltcG9ydCBHTCBmcm9tICdsdW1hLmdsL2NvbnN0YW50cyc7XG5pbXBvcnQge01vZGVsLCBDdWJlR2VvbWV0cnksIGZwNjR9IGZyb20gJ2x1bWEuZ2wnO1xuY29uc3Qge2ZwNjRMb3dQYXJ0fSA9IGZwNjQ7XG5cbmltcG9ydCB2cyBmcm9tICcuL2dwdS1ncmlkLWNlbGwtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IGZzIGZyb20gJy4vZ3B1LWdyaWQtY2VsbC1sYXllci1mcmFnbWVudC5nbHNsJztcblxuY29uc3QgREVGQVVMVF9NSU5DT0xPUiA9IFswLCAwLCAwLCAyNTVdO1xuY29uc3QgREVGQVVMVF9NQVhDT0xPUiA9IFswLCAyNTUsIDAsIDI1NV07XG5jb25zdCBBR0dSRUdBVElPTl9EQVRBX1VCT19JTkRFWCA9IDA7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgY2VsbFNpemU6IHt0eXBlOiAnbnVtYmVyJywgbWluOiAwLCBtYXg6IDIwLCB2YWx1ZTogMjB9LFxuICBjb3ZlcmFnZToge3R5cGU6ICdudW1iZXInLCBtaW46IDAsIG1heDogMSwgdmFsdWU6IDF9LFxuICBlbGV2YXRpb25TY2FsZToge3R5cGU6ICdudW1iZXInLCBtaW46IDAsIHZhbHVlOiAxfSxcbiAgZXh0cnVkZWQ6IHRydWUsXG4gIGZwNjQ6IGZhbHNlLFxuICBwaWNrYWJsZTogZmFsc2UsIC8vIFRPRE86IGFkZCBwaWNraW5nIHN1cHBvcnQgKHJlYWQgZnJvbSBhZ2dyZWdhdGVkIHRleHR1cmUpXG5cbiAgbWluQ29sb3I6IERFRkFVTFRfTUlOQ09MT1IsXG4gIG1heENvbG9yOiBERUZBVUxUX01BWENPTE9SLFxuXG4gIGxpZ2h0U2V0dGluZ3M6IHt9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHUFVHcmlkQ2VsbExheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiB7dnMsIGZzLCBtb2R1bGVzOiBbJ3Byb2plY3QzMicsICdsaWdodGluZycsICdwaWNraW5nJywgJ2ZwNjQnXX07XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3QgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlQ291bnRzOiB7XG4gICAgICAgIHNpemU6IDQsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZUNvdW50cyxcbiAgICAgICAgbm9BbGxvYzogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgc3VwZXIudXBkYXRlU3RhdGUoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KTtcbiAgICAvLyBSZS1nZW5lcmF0ZSBtb2RlbCBpZiBnZW9tZXRyeSBjaGFuZ2VkXG4gICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgICB0aGlzLnN0YXRlLm1vZGVsLmRlbGV0ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9nZXRNb2RlbChnbCk7XG4gICAgICB0aGlzLl9zZXR1cFVuaWZvcm1CdWZmZXIobW9kZWwpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWx9KTtcbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlKCdpbnN0YW5jZUNvdW50cycpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY291bnRzQnVmZmVyICE9PSBvbGRQcm9wcy5jb3VudHNCdWZmZXIpIHtcbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlKCdpbnN0YW5jZUNvdW50cycpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRNb2RlbChnbCkge1xuICAgIHJldHVybiBuZXcgTW9kZWwoXG4gICAgICBnbCxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0U2hhZGVycygpLCB7XG4gICAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgICBnZW9tZXRyeTogbmV3IEN1YmVHZW9tZXRyeSgpLFxuICAgICAgICBpc0luc3RhbmNlZDogdHJ1ZSxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFNpemUsXG4gICAgICBleHRydWRlZCxcbiAgICAgIGVsZXZhdGlvblNjYWxlLFxuICAgICAgY292ZXJhZ2UsXG4gICAgICBncmlkU2l6ZSxcbiAgICAgIGdyaWRPcmlnaW4sXG4gICAgICBncmlkT2Zmc2V0LFxuICAgICAgbWluQ29sb3IsXG4gICAgICBtYXhDb2xvcixcbiAgICAgIG1heENvdW50QnVmZmVyXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBncmlkT3JpZ2luTG93ID0gW2ZwNjRMb3dQYXJ0KGdyaWRPcmlnaW5bMF0pLCBmcDY0TG93UGFydChncmlkT3JpZ2luWzFdKV07XG4gICAgY29uc3QgZ3JpZE9mZnNldExvdyA9IFtmcDY0TG93UGFydChncmlkT2Zmc2V0WzBdKSwgZnA2NExvd1BhcnQoZ3JpZE9mZnNldFsxXSldO1xuXG4gICAgbWF4Q291bnRCdWZmZXIuYmluZCh7dGFyZ2V0OiBHTC5VTklGT1JNX0JVRkZFUiwgaW5kZXg6IEFHR1JFR0FUSU9OX0RBVEFfVUJPX0lOREVYfSk7XG4gICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIoXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB1bmlmb3Jtcywge1xuICAgICAgICBjZWxsU2l6ZSxcbiAgICAgICAgZXh0cnVkZWQsXG4gICAgICAgIGVsZXZhdGlvblNjYWxlLFxuICAgICAgICBjb3ZlcmFnZSxcbiAgICAgICAgZ3JpZFNpemUsXG4gICAgICAgIGdyaWRPcmlnaW4sXG4gICAgICAgIGdyaWRPcmlnaW5Mb3csXG4gICAgICAgIGdyaWRPZmZzZXQsXG4gICAgICAgIGdyaWRPZmZzZXRMb3csXG4gICAgICAgIG1pbkNvbG9yLFxuICAgICAgICBtYXhDb2xvclxuICAgICAgfSlcbiAgICApO1xuICAgIG1heENvdW50QnVmZmVyLnVuYmluZCh7dGFyZ2V0OiBHTC5VTklGT1JNX0JVRkZFUiwgaW5kZXg6IEFHR1JFR0FUSU9OX0RBVEFfVUJPX0lOREVYfSk7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZUNvdW50cyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB7Y291bnRzQnVmZmVyfSA9IHRoaXMucHJvcHM7XG4gICAgYXR0cmlidXRlLnVwZGF0ZSh7XG4gICAgICBidWZmZXI6IGNvdW50c0J1ZmZlclxuICAgIH0pO1xuICB9XG5cbiAgX3NldHVwVW5pZm9ybUJ1ZmZlcihtb2RlbCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0LmdsO1xuICAgIGNvbnN0IHByb2dyYW1IYW5kbGUgPSBtb2RlbC5wcm9ncmFtLmhhbmRsZTtcblxuICAgIGNvbnN0IHVuaWZvcm1CbG9ja0luZGV4ID0gZ2wuZ2V0VW5pZm9ybUJsb2NrSW5kZXgocHJvZ3JhbUhhbmRsZSwgJ0FnZ3JlZ2F0aW9uRGF0YScpO1xuICAgIGdsLnVuaWZvcm1CbG9ja0JpbmRpbmcocHJvZ3JhbUhhbmRsZSwgdW5pZm9ybUJsb2NrSW5kZXgsIEFHR1JFR0FUSU9OX0RBVEFfVUJPX0lOREVYKTtcbiAgfVxufVxuXG5HUFVHcmlkQ2VsbExheWVyLmxheWVyTmFtZSA9ICdHcmlkQ2VsbExheWVyJztcbkdQVUdyaWRDZWxsTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19