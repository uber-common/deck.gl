// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
const R_EARTH = 6378000;
import { Matrix4 } from 'math.gl';
import { fp64 as fp64Utils } from 'luma.gl';
const fp64LowPart = fp64Utils.fp64LowPart;
/**
 * Calculate density grid from an array of points
 * @param {array} points
 * @param {function} getPosition - position accessor
 * @param {number} cellSizeMeters - cell size in meters
 * @param {object} gpuGridAggregator - gpu aggregator
 * @param {bool} gpuAggregation - flag to enable gpu aggregation
 * @returns {object} - grid data, cell dimension
 */

export function pointToDensityGridData({
  data,
  getPosition,
  cellSizeMeters,
  gpuGridAggregator,
  gpuAggregation,
  fp64 = false
}) {
  const gridData = _parseData(data, getPosition);

  const gridOffset = _getGridOffset(gridData, cellSizeMeters);

  const opts = _getGPUAggregationParams(gridData, gridOffset);

  const aggregatedData = gpuGridAggregator.run({
    positions: opts.positions,
    positions64xyLow: opts.positions64xyLow,
    weights: opts.weights,
    cellSize: opts.cellSize,
    width: opts.width,
    height: opts.height,
    gridTransformMatrix: opts.gridTransformMatrix,
    useGPU: gpuAggregation,
    fp64
  });
  const gridSizeX = Math.ceil(opts.width / opts.cellSize[0]);
  const gridSizeY = Math.ceil(opts.height / opts.cellSize[1]);
  return {
    countsBuffer: aggregatedData.countsBuffer,
    maxCountBuffer: aggregatedData.maxCountBuffer,
    gridSize: [gridSizeX, gridSizeY],
    gridOrigin: opts.gridOrigin,
    gridOffset: [opts.gridOffset.xOffset, opts.gridOffset.yOffset]
  };
} // Aligns `inValue` to given `cellSize`

export function alignToCellBoundary(inValue, cellSize) {
  const sign = inValue < 0 ? -1 : 1;
  let value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);
  value = Math.floor(value / cellSize) * cellSize;
  return value * sign;
} // Calculate grid parameters

function _getGPUAggregationParams(gridData, gridOffset) {
  const latMin = gridData.latMin,
        latMax = gridData.latMax,
        lngMin = gridData.lngMin,
        lngMax = gridData.lngMax,
        positions = gridData.positions,
        positions64xyLow = gridData.positions64xyLow,
        weights = gridData.weights; // NOTE: this alignment will match grid cell boundaries with existing CPU implementation
  // this gurantees identical aggregation results between current and new layer.
  // We align the origin to cellSize in positive space lng:[0 360], lat:[0 180]
  // After alignment we move it back to original range
  // Origin = [minX, minY]
  // Origin = Origin + [180, 90] // moving to +ve space
  // Origin = Align(Origin, cellSize) //Align to cell boundary
  // Origin = Origin - [180, 90]

  const originY = alignToCellBoundary(latMin + 90, gridOffset.yOffset) - 90;
  const originX = alignToCellBoundary(lngMin + 180, gridOffset.xOffset) - 180; // Setup transformation matrix so that every point is in +ve range

  const gridTransformMatrix = new Matrix4().translate([-1 * originX, -1 * originY, 0]);
  const cellSize = [gridOffset.xOffset, gridOffset.yOffset];
  const gridOrigin = [originX, originY];
  const width = lngMax - lngMin + gridOffset.xOffset;
  const height = latMax - latMin + gridOffset.yOffset;
  return {
    positions,
    positions64xyLow,
    weights,
    cellSize,
    gridOrigin,
    width,
    height,
    gridTransformMatrix,
    gridOffset
  };
}
/**
 * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space
 * @param {array} points
 * @param {number} cellSize - unit size in meters
 * @param {function} getPosition - position accessor
 * @returns {yOffset, xOffset} - cellSize size lng/lat (degree) space.
 */


function _getGridOffset(gridData, cellSize) {
  const latMin = gridData.latMin,
        latMax = gridData.latMax;
  const centerLat = (latMin + latMax) / 2;
  return _calculateGridLatLonOffset(cellSize, centerLat);
}
/**
 * calculate grid layer cell size in lat lon based on world unit size
 * and current latitude
 * @param {number} cellSize
 * @param {number} latitude
 * @returns {object} - lat delta and lon delta
 */


function _calculateGridLatLonOffset(cellSize, latitude) {
  const yOffset = _calculateLatOffset(cellSize);

  const xOffset = _calculateLonOffset(latitude, cellSize);

  return {
    yOffset,
    xOffset
  };
}
/**
 * with a given x-km change, calculate the increment of latitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} dy - change in km
 * @return {number} - increment in latitude
 */


function _calculateLatOffset(dy) {
  return dy / R_EARTH * (180 / Math.PI);
}
/**
 * with a given x-km change, and current latitude
 * calculate the increment of longitude
 * based on stackoverflow http://stackoverflow.com/questions/7477003
 * @param {number} lat - latitude of current location (based on city)
 * @param {number} dx - change in km
 * @return {number} - increment in longitude
 */


function _calculateLonOffset(lat, dx) {
  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
} // Parse input data to build positions and boundaries.


function _parseData(data, getPosition) {
  const positions = [];
  const positions64xyLow = [];
  const weights = [];
  let latMin = Infinity;
  let latMax = -Infinity;
  let lngMin = Infinity;
  let lngMax = -Infinity;
  let pLat;
  let pLng;

  for (let p = 0; p < data.length; p++) {
    pLng = getPosition(data[p])[0];
    pLat = getPosition(data[p])[1];
    positions.push(pLng, pLat);
    positions64xyLow.push(fp64LowPart(pLng), fp64LowPart(pLat));
    weights.push(1.0);

    if (Number.isFinite(pLat) && Number.isFinite(pLng)) {
      latMin = pLat < latMin ? pLat : latMin;
      latMax = pLat > latMax ? pLat : latMax;
      lngMin = pLng < lngMin ? pLng : lngMin;
      lngMax = pLng > lngMax ? pLng : lngMax;
    }
  }

  return {
    positions,
    positions64xyLow,
    weights,
    latMin,
    latMax,
    lngMin,
    lngMax
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ncHUtZ3JpZC1sYXllci9ncHUtZ3JpZC11dGlscy5qcyJdLCJuYW1lcyI6WyJSX0VBUlRIIiwiTWF0cml4NCIsImZwNjQiLCJmcDY0VXRpbHMiLCJmcDY0TG93UGFydCIsInBvaW50VG9EZW5zaXR5R3JpZERhdGEiLCJkYXRhIiwiZ2V0UG9zaXRpb24iLCJjZWxsU2l6ZU1ldGVycyIsImdwdUdyaWRBZ2dyZWdhdG9yIiwiZ3B1QWdncmVnYXRpb24iLCJncmlkRGF0YSIsIl9wYXJzZURhdGEiLCJncmlkT2Zmc2V0IiwiX2dldEdyaWRPZmZzZXQiLCJvcHRzIiwiX2dldEdQVUFnZ3JlZ2F0aW9uUGFyYW1zIiwiYWdncmVnYXRlZERhdGEiLCJydW4iLCJwb3NpdGlvbnMiLCJwb3NpdGlvbnM2NHh5TG93Iiwid2VpZ2h0cyIsImNlbGxTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJncmlkVHJhbnNmb3JtTWF0cml4IiwidXNlR1BVIiwiZ3JpZFNpemVYIiwiTWF0aCIsImNlaWwiLCJncmlkU2l6ZVkiLCJjb3VudHNCdWZmZXIiLCJtYXhDb3VudEJ1ZmZlciIsImdyaWRTaXplIiwiZ3JpZE9yaWdpbiIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiYWxpZ25Ub0NlbGxCb3VuZGFyeSIsImluVmFsdWUiLCJzaWduIiwidmFsdWUiLCJhYnMiLCJmbG9vciIsImxhdE1pbiIsImxhdE1heCIsImxuZ01pbiIsImxuZ01heCIsIm9yaWdpblkiLCJvcmlnaW5YIiwidHJhbnNsYXRlIiwiY2VudGVyTGF0IiwiX2NhbGN1bGF0ZUdyaWRMYXRMb25PZmZzZXQiLCJsYXRpdHVkZSIsIl9jYWxjdWxhdGVMYXRPZmZzZXQiLCJfY2FsY3VsYXRlTG9uT2Zmc2V0IiwiZHkiLCJQSSIsImxhdCIsImR4IiwiY29zIiwiSW5maW5pdHkiLCJwTGF0IiwicExuZyIsInAiLCJsZW5ndGgiLCJwdXNoIiwiTnVtYmVyIiwiaXNGaW5pdGUiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFD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S0FBS3lELENBQUwsQ0FBWixFQUFxQixDQUFyQixDQUFQO0FBRUE1QyxjQUFVOEMsSUFBVixDQUFlSCxJQUFmLEVBQXFCRCxJQUFyQjtBQUNBekMscUJBQWlCNkMsSUFBakIsQ0FBc0I3RCxZQUFZMEQsSUFBWixDQUF0QixFQUF5QzFELFlBQVl5RCxJQUFaLENBQXpDO0FBQ0F4QyxZQUFRNEMsSUFBUixDQUFhLEdBQWI7O0FBRUEsUUFBSUMsT0FBT0MsUUFBUCxDQUFnQk4sSUFBaEIsS0FBeUJLLE9BQU9DLFFBQVAsQ0FBZ0JMLElBQWhCLENBQTdCLEVBQW9EO0FBQ2xEbkIsZUFBU2tCLE9BQU9sQixNQUFQLEdBQWdCa0IsSUFBaEIsR0FBdUJsQixNQUFoQztBQUNBQyxlQUFTaUIsT0FBT2pCLE1BQVAsR0FBZ0JpQixJQUFoQixHQUF1QmpCLE1BQWhDO0FBRUFDLGVBQVNpQixPQUFPakIsTUFBUCxHQUFnQmlCLElBQWhCLEdBQXVCakIsTUFBaEM7QUFDQUMsZUFBU2dCLE9BQU9oQixNQUFQLEdBQWdCZ0IsSUFBaEIsR0FBdUJoQixNQUFoQztBQUNEO0FBQ0Y7O0FBRUQsU0FBTztBQUNMM0IsYUFESztBQUVMQyxvQkFGSztBQUdMQyxXQUhLO0FBSUxzQixVQUpLO0FBS0xDLFVBTEs7QUFNTEMsVUFOSztBQU9MQztBQVBLLEdBQVA7QUFTRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5jb25zdCBSX0VBUlRIID0gNjM3ODAwMDtcblxuaW1wb3J0IHtNYXRyaXg0fSBmcm9tICdtYXRoLmdsJztcbmltcG9ydCB7ZnA2NCBhcyBmcDY0VXRpbHN9IGZyb20gJ2x1bWEuZ2wnO1xuY29uc3Qge2ZwNjRMb3dQYXJ0fSA9IGZwNjRVdGlscztcblxuLyoqXG4gKiBDYWxjdWxhdGUgZGVuc2l0eSBncmlkIGZyb20gYW4gYXJyYXkgb2YgcG9pbnRzXG4gKiBAcGFyYW0ge2FycmF5fSBwb2ludHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldFBvc2l0aW9uIC0gcG9zaXRpb24gYWNjZXNzb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsU2l6ZU1ldGVycyAtIGNlbGwgc2l6ZSBpbiBtZXRlcnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBncHVHcmlkQWdncmVnYXRvciAtIGdwdSBhZ2dyZWdhdG9yXG4gKiBAcGFyYW0ge2Jvb2x9IGdwdUFnZ3JlZ2F0aW9uIC0gZmxhZyB0byBlbmFibGUgZ3B1IGFnZ3JlZ2F0aW9uXG4gKiBAcmV0dXJucyB7b2JqZWN0fSAtIGdyaWQgZGF0YSwgY2VsbCBkaW1lbnNpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvaW50VG9EZW5zaXR5R3JpZERhdGEoe1xuICBkYXRhLFxuICBnZXRQb3NpdGlvbixcbiAgY2VsbFNpemVNZXRlcnMsXG4gIGdwdUdyaWRBZ2dyZWdhdG9yLFxuICBncHVBZ2dyZWdhdGlvbixcbiAgZnA2NCA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IGdyaWREYXRhID0gX3BhcnNlRGF0YShkYXRhLCBnZXRQb3NpdGlvbik7XG4gIGNvbnN0IGdyaWRPZmZzZXQgPSBfZ2V0R3JpZE9mZnNldChncmlkRGF0YSwgY2VsbFNpemVNZXRlcnMpO1xuXG4gIGNvbnN0IG9wdHMgPSBfZ2V0R1BVQWdncmVnYXRpb25QYXJhbXMoZ3JpZERhdGEsIGdyaWRPZmZzZXQpO1xuXG4gIGNvbnN0IGFnZ3JlZ2F0ZWREYXRhID0gZ3B1R3JpZEFnZ3JlZ2F0b3IucnVuKHtcbiAgICBwb3NpdGlvbnM6IG9wdHMucG9zaXRpb25zLFxuICAgIHBvc2l0aW9uczY0eHlMb3c6IG9wdHMucG9zaXRpb25zNjR4eUxvdyxcbiAgICB3ZWlnaHRzOiBvcHRzLndlaWdodHMsXG4gICAgY2VsbFNpemU6IG9wdHMuY2VsbFNpemUsXG4gICAgd2lkdGg6IG9wdHMud2lkdGgsXG4gICAgaGVpZ2h0OiBvcHRzLmhlaWdodCxcbiAgICBncmlkVHJhbnNmb3JtTWF0cml4OiBvcHRzLmdyaWRUcmFuc2Zvcm1NYXRyaXgsXG4gICAgdXNlR1BVOiBncHVBZ2dyZWdhdGlvbixcbiAgICBmcDY0XG4gIH0pO1xuXG4gIGNvbnN0IGdyaWRTaXplWCA9IE1hdGguY2VpbChvcHRzLndpZHRoIC8gb3B0cy5jZWxsU2l6ZVswXSk7XG4gIGNvbnN0IGdyaWRTaXplWSA9IE1hdGguY2VpbChvcHRzLmhlaWdodCAvIG9wdHMuY2VsbFNpemVbMV0pO1xuXG4gIHJldHVybiB7XG4gICAgY291bnRzQnVmZmVyOiBhZ2dyZWdhdGVkRGF0YS5jb3VudHNCdWZmZXIsXG4gICAgbWF4Q291bnRCdWZmZXI6IGFnZ3JlZ2F0ZWREYXRhLm1heENvdW50QnVmZmVyLFxuICAgIGdyaWRTaXplOiBbZ3JpZFNpemVYLCBncmlkU2l6ZVldLFxuICAgIGdyaWRPcmlnaW46IG9wdHMuZ3JpZE9yaWdpbixcbiAgICBncmlkT2Zmc2V0OiBbb3B0cy5ncmlkT2Zmc2V0LnhPZmZzZXQsIG9wdHMuZ3JpZE9mZnNldC55T2Zmc2V0XVxuICB9O1xufVxuXG4vLyBBbGlnbnMgYGluVmFsdWVgIHRvIGdpdmVuIGBjZWxsU2l6ZWBcbmV4cG9ydCBmdW5jdGlvbiBhbGlnblRvQ2VsbEJvdW5kYXJ5KGluVmFsdWUsIGNlbGxTaXplKSB7XG4gIGNvbnN0IHNpZ24gPSBpblZhbHVlIDwgMCA/IC0xIDogMTtcblxuICBsZXQgdmFsdWUgPSBzaWduIDwgMCA/IE1hdGguYWJzKGluVmFsdWUpICsgY2VsbFNpemUgOiBNYXRoLmFicyhpblZhbHVlKTtcblxuICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgLyBjZWxsU2l6ZSkgKiBjZWxsU2l6ZTtcblxuICByZXR1cm4gdmFsdWUgKiBzaWduO1xufVxuXG4vLyBDYWxjdWxhdGUgZ3JpZCBwYXJhbWV0ZXJzXG5mdW5jdGlvbiBfZ2V0R1BVQWdncmVnYXRpb25QYXJhbXMoZ3JpZERhdGEsIGdyaWRPZmZzZXQpIHtcbiAgY29uc3Qge2xhdE1pbiwgbGF0TWF4LCBsbmdNaW4sIGxuZ01heCwgcG9zaXRpb25zLCBwb3NpdGlvbnM2NHh5TG93LCB3ZWlnaHRzfSA9IGdyaWREYXRhO1xuXG4gIC8vIE5PVEU6IHRoaXMgYWxpZ25tZW50IHdpbGwgbWF0Y2ggZ3JpZCBjZWxsIGJvdW5kYXJpZXMgd2l0aCBleGlzdGluZyBDUFUgaW1wbGVtZW50YXRpb25cbiAgLy8gdGhpcyBndXJhbnRlZXMgaWRlbnRpY2FsIGFnZ3JlZ2F0aW9uIHJlc3VsdHMgYmV0d2VlbiBjdXJyZW50IGFuZCBuZXcgbGF5ZXIuXG4gIC8vIFdlIGFsaWduIHRoZSBvcmlnaW4gdG8gY2VsbFNpemUgaW4gcG9zaXRpdmUgc3BhY2UgbG5nOlswIDM2MF0sIGxhdDpbMCAxODBdXG4gIC8vIEFmdGVyIGFsaWdubWVudCB3ZSBtb3ZlIGl0IGJhY2sgdG8gb3JpZ2luYWwgcmFuZ2VcbiAgLy8gT3JpZ2luID0gW21pblgsIG1pblldXG4gIC8vIE9yaWdpbiA9IE9yaWdpbiArIFsxODAsIDkwXSAvLyBtb3ZpbmcgdG8gK3ZlIHNwYWNlXG4gIC8vIE9yaWdpbiA9IEFsaWduKE9yaWdpbiwgY2VsbFNpemUpIC8vQWxpZ24gdG8gY2VsbCBib3VuZGFyeVxuICAvLyBPcmlnaW4gPSBPcmlnaW4gLSBbMTgwLCA5MF1cbiAgY29uc3Qgb3JpZ2luWSA9IGFsaWduVG9DZWxsQm91bmRhcnkobGF0TWluICsgOTAsIGdyaWRPZmZzZXQueU9mZnNldCkgLSA5MDtcbiAgY29uc3Qgb3JpZ2luWCA9IGFsaWduVG9DZWxsQm91bmRhcnkobG5nTWluICsgMTgwLCBncmlkT2Zmc2V0LnhPZmZzZXQpIC0gMTgwO1xuXG4gIC8vIFNldHVwIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBzbyB0aGF0IGV2ZXJ5IHBvaW50IGlzIGluICt2ZSByYW5nZVxuICBjb25zdCBncmlkVHJhbnNmb3JtTWF0cml4ID0gbmV3IE1hdHJpeDQoKS50cmFuc2xhdGUoWy0xICogb3JpZ2luWCwgLTEgKiBvcmlnaW5ZLCAwXSk7XG5cbiAgY29uc3QgY2VsbFNpemUgPSBbZ3JpZE9mZnNldC54T2Zmc2V0LCBncmlkT2Zmc2V0LnlPZmZzZXRdO1xuICBjb25zdCBncmlkT3JpZ2luID0gW29yaWdpblgsIG9yaWdpblldO1xuICBjb25zdCB3aWR0aCA9IGxuZ01heCAtIGxuZ01pbiArIGdyaWRPZmZzZXQueE9mZnNldDtcbiAgY29uc3QgaGVpZ2h0ID0gbGF0TWF4IC0gbGF0TWluICsgZ3JpZE9mZnNldC55T2Zmc2V0O1xuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb25zLFxuICAgIHBvc2l0aW9uczY0eHlMb3csXG4gICAgd2VpZ2h0cyxcbiAgICBjZWxsU2l6ZSxcbiAgICBncmlkT3JpZ2luLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBncmlkVHJhbnNmb3JtTWF0cml4LFxuICAgIGdyaWRPZmZzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBCYXNlZCBvbiBnZW9tZXRyaWMgY2VudGVyIG9mIHNhbXBsZSBwb2ludHMsIGNhbGN1bGF0ZSBjZWxsU2l6ZSBpbiBsbmcvbGF0IChkZWdyZWUpIHNwYWNlXG4gKiBAcGFyYW0ge2FycmF5fSBwb2ludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsU2l6ZSAtIHVuaXQgc2l6ZSBpbiBtZXRlcnNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldFBvc2l0aW9uIC0gcG9zaXRpb24gYWNjZXNzb3JcbiAqIEByZXR1cm5zIHt5T2Zmc2V0LCB4T2Zmc2V0fSAtIGNlbGxTaXplIHNpemUgbG5nL2xhdCAoZGVncmVlKSBzcGFjZS5cbiAqL1xuXG5mdW5jdGlvbiBfZ2V0R3JpZE9mZnNldChncmlkRGF0YSwgY2VsbFNpemUpIHtcbiAgY29uc3Qge2xhdE1pbiwgbGF0TWF4fSA9IGdyaWREYXRhO1xuXG4gIGNvbnN0IGNlbnRlckxhdCA9IChsYXRNaW4gKyBsYXRNYXgpIC8gMjtcblxuICByZXR1cm4gX2NhbGN1bGF0ZUdyaWRMYXRMb25PZmZzZXQoY2VsbFNpemUsIGNlbnRlckxhdCk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIGdyaWQgbGF5ZXIgY2VsbCBzaXplIGluIGxhdCBsb24gYmFzZWQgb24gd29ybGQgdW5pdCBzaXplXG4gKiBhbmQgY3VycmVudCBsYXRpdHVkZVxuICogQHBhcmFtIHtudW1iZXJ9IGNlbGxTaXplXG4gKiBAcGFyYW0ge251bWJlcn0gbGF0aXR1ZGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gbGF0IGRlbHRhIGFuZCBsb24gZGVsdGFcbiAqL1xuZnVuY3Rpb24gX2NhbGN1bGF0ZUdyaWRMYXRMb25PZmZzZXQoY2VsbFNpemUsIGxhdGl0dWRlKSB7XG4gIGNvbnN0IHlPZmZzZXQgPSBfY2FsY3VsYXRlTGF0T2Zmc2V0KGNlbGxTaXplKTtcbiAgY29uc3QgeE9mZnNldCA9IF9jYWxjdWxhdGVMb25PZmZzZXQobGF0aXR1ZGUsIGNlbGxTaXplKTtcbiAgcmV0dXJuIHt5T2Zmc2V0LCB4T2Zmc2V0fTtcbn1cblxuLyoqXG4gKiB3aXRoIGEgZ2l2ZW4geC1rbSBjaGFuZ2UsIGNhbGN1bGF0ZSB0aGUgaW5jcmVtZW50IG9mIGxhdGl0dWRlXG4gKiBiYXNlZCBvbiBzdGFja292ZXJmbG93IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQ3NzAwM1xuICogQHBhcmFtIHtudW1iZXJ9IGR5IC0gY2hhbmdlIGluIGttXG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gaW5jcmVtZW50IGluIGxhdGl0dWRlXG4gKi9cbmZ1bmN0aW9uIF9jYWxjdWxhdGVMYXRPZmZzZXQoZHkpIHtcbiAgcmV0dXJuIChkeSAvIFJfRUFSVEgpICogKDE4MCAvIE1hdGguUEkpO1xufVxuXG4vKipcbiAqIHdpdGggYSBnaXZlbiB4LWttIGNoYW5nZSwgYW5kIGN1cnJlbnQgbGF0aXR1ZGVcbiAqIGNhbGN1bGF0ZSB0aGUgaW5jcmVtZW50IG9mIGxvbmdpdHVkZVxuICogYmFzZWQgb24gc3RhY2tvdmVyZmxvdyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc0NzcwMDNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgLSBsYXRpdHVkZSBvZiBjdXJyZW50IGxvY2F0aW9uIChiYXNlZCBvbiBjaXR5KVxuICogQHBhcmFtIHtudW1iZXJ9IGR4IC0gY2hhbmdlIGluIGttXG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gaW5jcmVtZW50IGluIGxvbmdpdHVkZVxuICovXG5mdW5jdGlvbiBfY2FsY3VsYXRlTG9uT2Zmc2V0KGxhdCwgZHgpIHtcbiAgcmV0dXJuICgoZHggLyBSX0VBUlRIKSAqICgxODAgLyBNYXRoLlBJKSkgLyBNYXRoLmNvcygobGF0ICogTWF0aC5QSSkgLyAxODApO1xufVxuXG4vLyBQYXJzZSBpbnB1dCBkYXRhIHRvIGJ1aWxkIHBvc2l0aW9ucyBhbmQgYm91bmRhcmllcy5cbmZ1bmN0aW9uIF9wYXJzZURhdGEoZGF0YSwgZ2V0UG9zaXRpb24pIHtcbiAgY29uc3QgcG9zaXRpb25zID0gW107XG4gIGNvbnN0IHBvc2l0aW9uczY0eHlMb3cgPSBbXTtcbiAgY29uc3Qgd2VpZ2h0cyA9IFtdO1xuXG4gIGxldCBsYXRNaW4gPSBJbmZpbml0eTtcbiAgbGV0IGxhdE1heCA9IC1JbmZpbml0eTtcbiAgbGV0IGxuZ01pbiA9IEluZmluaXR5O1xuICBsZXQgbG5nTWF4ID0gLUluZmluaXR5O1xuICBsZXQgcExhdDtcbiAgbGV0IHBMbmc7XG4gIGZvciAobGV0IHAgPSAwOyBwIDwgZGF0YS5sZW5ndGg7IHArKykge1xuICAgIHBMbmcgPSBnZXRQb3NpdGlvbihkYXRhW3BdKVswXTtcbiAgICBwTGF0ID0gZ2V0UG9zaXRpb24oZGF0YVtwXSlbMV07XG5cbiAgICBwb3NpdGlvbnMucHVzaChwTG5nLCBwTGF0KTtcbiAgICBwb3NpdGlvbnM2NHh5TG93LnB1c2goZnA2NExvd1BhcnQocExuZyksIGZwNjRMb3dQYXJ0KHBMYXQpKTtcbiAgICB3ZWlnaHRzLnB1c2goMS4wKTtcblxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocExhdCkgJiYgTnVtYmVyLmlzRmluaXRlKHBMbmcpKSB7XG4gICAgICBsYXRNaW4gPSBwTGF0IDwgbGF0TWluID8gcExhdCA6IGxhdE1pbjtcbiAgICAgIGxhdE1heCA9IHBMYXQgPiBsYXRNYXggPyBwTGF0IDogbGF0TWF4O1xuXG4gICAgICBsbmdNaW4gPSBwTG5nIDwgbG5nTWluID8gcExuZyA6IGxuZ01pbjtcbiAgICAgIGxuZ01heCA9IHBMbmcgPiBsbmdNYXggPyBwTG5nIDogbG5nTWF4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb25zLFxuICAgIHBvc2l0aW9uczY0eHlMb3csXG4gICAgd2VpZ2h0cyxcbiAgICBsYXRNaW4sXG4gICAgbGF0TWF4LFxuICAgIGxuZ01pbixcbiAgICBsbmdNYXhcbiAgfTtcbn1cbiJdfQ==