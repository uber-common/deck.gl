// All utility mehtods needed to implement Marching Squres algorithm
// Ref: https://en.wikipedia.org/wiki/Marching_squares
import assert from 'assert'; // Table to map code to the intersection offsets
// All offsets are relative to the center of marching cell (which is top right corner of grid-cell)

const OFFSET = {
  N: [0, 0.5],
  E: [0.5, 0],
  S: [0, -0.5],
  W: [-0.5, 0]
}; // Note: above wiki page invertes white/black dots for generating the code, we don't

const CODE_OFFSET_MAP = {
  0: [],
  1: [[OFFSET.W, OFFSET.S]],
  2: [[OFFSET.S, OFFSET.E]],
  3: [[OFFSET.W, OFFSET.E]],
  4: [[OFFSET.N, OFFSET.E]],
  5: [[OFFSET.W, OFFSET.N], [OFFSET.S, OFFSET.E]],
  6: [[OFFSET.N, OFFSET.S]],
  7: [[OFFSET.W, OFFSET.N]],
  8: [[OFFSET.W, OFFSET.N]],
  9: [[OFFSET.N, OFFSET.S]],
  10: [[OFFSET.W, OFFSET.S], [OFFSET.N, OFFSET.E]],
  11: [[OFFSET.N, OFFSET.E]],
  12: [[OFFSET.W, OFFSET.E]],
  13: [[OFFSET.S, OFFSET.E]],
  14: [[OFFSET.W, OFFSET.S]],
  15: []
}; // Returns marching square code for given cell

export function getCode(params) {
  // Assumptions
  // Origin is on bottom-left , and X increase to right, Y to top
  // When processing one cell, we process 4 cells, by extending row to top and on column to right
  // to create a 2X2 cell grid
  const cellWeights = params.cellWeights,
        thresholdValue = params.thresholdValue,
        cellIndex = params.cellIndex,
        gridSize = params.gridSize;
  const numRows = gridSize[1];
  const numCols = gridSize[0]; // TODO: duplicate top row and right column
  // We shouldn't process the right column

  assert((cellIndex + 1) % numCols); // We shouldn't process the topmost row

  assert(cellIndex + 1 < (numRows - 1) * numCols);
  const top = cellWeights[cellIndex + numCols] - thresholdValue >= 0 ? 1 : 0;
  const topRight = cellWeights[cellIndex + numCols + 1] - thresholdValue >= 0 ? 1 : 0;
  const right = cellWeights[cellIndex + 1] - thresholdValue >= 0 ? 1 : 0;
  const current = cellWeights[cellIndex] - thresholdValue >= 0 ? 1 : 0;
  const code = top << 3 | topRight << 2 | right << 1 | current;
  assert(code >= 0 && code < 16);
  return code;
} // Returns intersection vertices for given cellindex

export function getVertices(params) {
  const gridOrigin = params.gridOrigin,
        cellIndex = params.cellIndex,
        cellSize = params.cellSize,
        gridSize = params.gridSize,
        code = params.code;
  const offsets = CODE_OFFSET_MAP[code]; // Reference vertex is top-right its co-ordinates are stored at index 0(X) and 1(Y)

  const row = Math.floor(cellIndex / gridSize[0]);
  const col = cellIndex - row * gridSize[0]; // Move to top-right corner

  const rX = (col + 1) * cellSize[0];
  const rY = (row + 1) * cellSize[1];
  const refVertexX = gridOrigin[0] + rX;
  const refVertexY = gridOrigin[1] + rY;
  const vertices = [];
  offsets.forEach(xyOffsets => {
    xyOffsets.forEach(offset => {
      const x = refVertexX + offset[0] * cellSize[0];
      const y = refVertexY + offset[1] * cellSize[1];
      vertices.push([x, y]);
    });
  });
  return vertices;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb250b3VyLWxheWVyL21hcmNoaW5nLXNxdWFyZXMuanMiXSwibmFtZXMiOlsiYXNzZXJ0IiwiT0ZGU0VUIiwiTiIsIkUiLCJTIiwiVyIsIkNPREVfT0ZGU0VUX01BUCIsImdldENvZGUiLCJwYXJhbXMiLCJjZWxsV2VpZ2h0cyIsInRocmVzaG9sZFZhbHVlIiwiY2VsbEluZGV4IiwiZ3JpZFNpemUiLCJudW1Sb3dzIiwibnVtQ29scyIsInRvcCIsInRvcFJpZ2h0IiwicmlnaHQiLCJjdXJyZW50IiwiY29kZSIsImdldFZlcnRpY2VzIiwiZ3JpZE9yaWdpbiIsImNlbGxTaXplIiwib2Zmc2V0cyIsInJvdyIsIk1hdGgiLCJmbG9vciIsImNvbCIsInJYIiwiclkiLCJyZWZWZXJ0ZXhYIiwicmVmVmVydGV4WSIsInZlcnRpY2VzIiwiZm9yRWFjaCIsInh5T2Zmc2V0cyIsIm9mZnNldCIsIngiLCJ5IiwicHVzaCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLE9BQU9BLE1BQVAsTUFBbUIsUUFBbkIsQyxDQUVBO0FBQ0E7O0FBQ0EsTUFBTUMsU0FBUztBQUNiQyxLQUFHLENBQUMsQ0FBRCxFQUFJLEdBQUosQ0FEVTtBQUViQyxLQUFHLENBQUMsR0FBRCxFQUFNLENBQU4sQ0FGVTtBQUdiQyxLQUFHLENBQUMsQ0FBRCxFQUFJLENBQUMsR0FBTCxDQUhVO0FBSWJDLEtBQUcsQ0FBQyxDQUFDLEdBQUYsRUFBTyxDQUFQO0FBSlUsQ0FBZixDLENBT0E7O0FBQ0EsTUFBTUMsa0JBQWtCO0FBQ3RCLEtBQUcsRUFEbUI7QUFFdEIsS0FBRyxDQUFDLENBQUNMLE9BQU9JLENBQVIsRUFBV0osT0FBT0csQ0FBbEIsQ0FBRCxDQUZtQjtBQUd0QixLQUFHLENBQUMsQ0FBQ0gsT0FBT0csQ0FBUixFQUFXSCxPQUFPRSxDQUFsQixDQUFELENBSG1CO0FBSXRCLEtBQUcsQ0FBQyxDQUFDRixPQUFPSSxDQUFSLEVBQVdKLE9BQU9FLENBQWxCLENBQUQsQ0FK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VUFEMkI7QUFBQSxRQUNmVixTQURlLEdBQ3dCSCxNQUR4QixDQUNmRyxTQURlO0FBQUEsUUFDSlcsUUFESSxHQUN3QmQsTUFEeEIsQ0FDSmMsUUFESTtBQUFBLFFBQ01WLFFBRE4sR0FDd0JKLE1BRHhCLENBQ01JLFFBRE47QUFBQSxRQUNnQk8sSUFEaEIsR0FDd0JYLE1BRHhCLENBQ2dCVyxJQURoQjtBQUdsQyxRQUFNSSxVQUFVakIsZ0JBQWdCYSxJQUFoQixDQUFoQixDQUhrQyxDQUlsQzs7QUFDQSxRQUFNSyxNQUFNQyxLQUFLQyxLQUFMLENBQVdmLFlBQVlDLFNBQVMsQ0FBVCxDQUF2QixDQUFaO0FBQ0EsUUFBTWUsTUFBTWhCLFlBQVlhLE1BQU1aLFNBQVMsQ0FBVCxDQUE5QixDQU5rQyxDQVFsQzs7QUFDQSxRQUFNZ0IsS0FBSyxDQUFDRCxNQUFNLENBQVAsSUFBWUwsU0FBUyxDQUFULENBQXZCO0FBQ0EsUUFBTU8sS0FBSyxDQUFDTCxNQUFNLENBQVAsSUFBWUYsU0FBUyxDQUFULENBQXZCO0FBRUEsUUFBTVEsYUFBYVQsV0FBVyxDQUFYLElBQWdCTyxFQUFuQztBQUNBLFFBQU1HLGFBQWFWLFdBQVcsQ0FBWCxJQUFnQlEsRUFBbkM7QUFFQSxRQUFNRyxXQUFXLEVBQWpCO0FBQ0FULFVBQVFVLE9BQVIsQ0FBZ0JDLGFBQWE7QUFDM0JBLGNBQVVELE9BQVYsQ0FBa0JFLFVBQVU7QUFDMUIsWUFBTUMsSUFBSU4sYUFBYUssT0FBTyxDQUFQLElBQVliLFNBQVMsQ0FBVCxDQUFuQztBQUNBLFlBQU1lLElBQUlOLGFBQWFJLE9BQU8sQ0FBUCxJQUFZYixTQUFTLENBQVQsQ0FBbkM7QUFDQVUsZUFBU00sSUFBVCxDQUFjLENBQUNGLENBQUQsRUFBSUMsQ0FBSixDQUFkO0FBQ0QsS0FKRDtBQUtELEdBTkQ7QUFRQSxTQUFPTCxRQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBbGwgdXRpbGl0eSBtZWh0b2RzIG5lZWRlZCB0byBpbXBsZW1lbnQgTWFyY2hpbmcgU3F1cmVzIGFsZ29yaXRobVxuLy8gUmVmOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXJjaGluZ19zcXVhcmVzXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8vIFRhYmxlIHRvIG1hcCBjb2RlIHRvIHRoZSBpbnRlcnNlY3Rpb24gb2Zmc2V0c1xuLy8gQWxsIG9mZnNldHMgYXJlIHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFyY2hpbmcgY2VsbCAod2hpY2ggaXMgdG9wIHJpZ2h0IGNvcm5lciBvZiBncmlkLWNlbGwpXG5jb25zdCBPRkZTRVQgPSB7XG4gIE46IFswLCAwLjVdLFxuICBFOiBbMC41LCAwXSxcbiAgUzogWzAsIC0wLjVdLFxuICBXOiBbLTAuNSwgMF1cbn07XG5cbi8vIE5vdGU6IGFib3ZlIHdpa2kgcGFnZSBpbnZlcnRlcyB3aGl0ZS9ibGFjayBkb3RzIGZvciBnZW5lcmF0aW5nIHRoZSBjb2RlLCB3ZSBkb24ndFxuY29uc3QgQ09ERV9PRkZTRVRfTUFQID0ge1xuICAwOiBbXSxcbiAgMTogW1tPRkZTRVQuVywgT0ZGU0VULlNdXSxcbiAgMjogW1tPRkZTRVQuUywgT0ZGU0VULkVdXSxcbiAgMzogW1tPRkZTRVQuVywgT0ZGU0VULkVdXSxcbiAgNDogW1tPRkZTRVQuTiwgT0ZGU0VULkVdXSxcbiAgNTogW1tPRkZTRVQuVywgT0ZGU0VULk5dLCBbT0ZGU0VULlMsIE9GRlNFVC5FXV0sXG4gIDY6IFtbT0ZGU0VULk4sIE9GRlNFVC5TXV0sXG4gIDc6IFtbT0ZGU0VULlcsIE9GRlNFVC5OXV0sXG4gIDg6IFtbT0ZGU0VULlcsIE9GRlNFVC5OXV0sXG4gIDk6IFtbT0ZGU0VULk4sIE9GRlNFVC5TXV0sXG4gIDEwOiBbW09GRlNFVC5XLCBPRkZTRVQuU10sIFtPRkZTRVQuTiwgT0ZGU0VULkVdXSxcbiAgMTE6IFtbT0ZGU0VULk4sIE9GRlNFVC5FXV0sXG4gIDEyOiBbW09GRlNFVC5XLCBPRkZTRVQuRV1dLFxuICAxMzogW1tPRkZTRVQuUywgT0ZGU0VULkVdXSxcbiAgMTQ6IFtbT0ZGU0VULlcsIE9GRlNFVC5TXV0sXG4gIDE1OiBbXVxufTtcblxuLy8gUmV0dXJucyBtYXJjaGluZyBzcXVhcmUgY29kZSBmb3IgZ2l2ZW4gY2VsbFxuZXhwb3J0IGZ1bmN0aW9uIGdldENvZGUocGFyYW1zKSB7XG4gIC8vIEFzc3VtcHRpb25zXG4gIC8vIE9yaWdpbiBpcyBvbiBib3R0b20tbGVmdCAsIGFuZCBYIGluY3JlYXNlIHRvIHJpZ2h0LCBZIHRvIHRvcFxuICAvLyBXaGVuIHByb2Nlc3Npbmcgb25lIGNlbGwsIHdlIHByb2Nlc3MgNCBjZWxscywgYnkgZXh0ZW5kaW5nIHJvdyB0byB0b3AgYW5kIG9uIGNvbHVtbiB0byByaWdodFxuICAvLyB0byBjcmVhdGUgYSAyWDIgY2VsbCBncmlkXG5cbiAgY29uc3Qge2NlbGxXZWlnaHRzLCB0aHJlc2hvbGRWYWx1ZSwgY2VsbEluZGV4LCBncmlkU2l6ZX0gPSBwYXJhbXM7XG5cbiAgY29uc3QgbnVtUm93cyA9IGdyaWRTaXplWzFdO1xuICBjb25zdCBudW1Db2xzID0gZ3JpZFNpemVbMF07XG5cbiAgLy8gVE9ETzogZHVwbGljYXRlIHRvcCByb3cgYW5kIHJpZ2h0IGNvbHVtblxuICAvLyBXZSBzaG91bGRuJ3QgcHJvY2VzcyB0aGUgcmlnaHQgY29sdW1uXG4gIGFzc2VydCgoY2VsbEluZGV4ICsgMSkgJSBudW1Db2xzKTtcbiAgLy8gV2Ugc2hvdWxkbid0IHByb2Nlc3MgdGhlIHRvcG1vc3Qgcm93XG4gIGFzc2VydChjZWxsSW5kZXggKyAxIDwgKG51bVJvd3MgLSAxKSAqIG51bUNvbHMpO1xuXG4gIGNvbnN0IHRvcCA9IGNlbGxXZWlnaHRzW2NlbGxJbmRleCArIG51bUNvbHNdIC0gdGhyZXNob2xkVmFsdWUgPj0gMCA/IDEgOiAwO1xuICBjb25zdCB0b3BSaWdodCA9IGNlbGxXZWlnaHRzW2NlbGxJbmRleCArIG51bUNvbHMgKyAxXSAtIHRocmVzaG9sZFZhbHVlID49IDAgPyAxIDogMDtcbiAgY29uc3QgcmlnaHQgPSBjZWxsV2VpZ2h0c1tjZWxsSW5kZXggKyAxXSAtIHRocmVzaG9sZFZhbHVlID49IDAgPyAxIDogMDtcbiAgY29uc3QgY3VycmVudCA9IGNlbGxXZWlnaHRzW2NlbGxJbmRleF0gLSB0aHJlc2hvbGRWYWx1ZSA+PSAwID8gMSA6IDA7XG5cbiAgY29uc3QgY29kZSA9ICh0b3AgPDwgMykgfCAodG9wUmlnaHQgPDwgMikgfCAocmlnaHQgPDwgMSkgfCBjdXJyZW50O1xuXG4gIGFzc2VydChjb2RlID49IDAgJiYgY29kZSA8IDE2KTtcblxuICByZXR1cm4gY29kZTtcbn1cblxuLy8gUmV0dXJucyBpbnRlcnNlY3Rpb24gdmVydGljZXMgZm9yIGdpdmVuIGNlbGxpbmRleFxuZXhwb3J0IGZ1bmN0aW9uIGdldFZlcnRpY2VzKHBhcmFtcykge1xuICBjb25zdCB7Z3JpZE9yaWdpbiwgY2VsbEluZGV4LCBjZWxsU2l6ZSwgZ3JpZFNpemUsIGNvZGV9ID0gcGFyYW1zO1xuXG4gIGNvbnN0IG9mZnNldHMgPSBDT0RFX09GRlNFVF9NQVBbY29kZV07XG4gIC8vIFJlZmVyZW5jZSB2ZXJ0ZXggaXMgdG9wLXJpZ2h0IGl0cyBjby1vcmRpbmF0ZXMgYXJlIHN0b3JlZCBhdCBpbmRleCAwKFgpIGFuZCAxKFkpXG4gIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoY2VsbEluZGV4IC8gZ3JpZFNpemVbMF0pO1xuICBjb25zdCBjb2wgPSBjZWxsSW5kZXggLSByb3cgKiBncmlkU2l6ZVswXTtcblxuICAvLyBNb3ZlIHRvIHRvcC1yaWdodCBjb3JuZXJcbiAgY29uc3QgclggPSAoY29sICsgMSkgKiBjZWxsU2l6ZVswXTtcbiAgY29uc3QgclkgPSAocm93ICsgMSkgKiBjZWxsU2l6ZVsxXTtcblxuICBjb25zdCByZWZWZXJ0ZXhYID0gZ3JpZE9yaWdpblswXSArIHJYO1xuICBjb25zdCByZWZWZXJ0ZXhZID0gZ3JpZE9yaWdpblsxXSArIHJZO1xuXG4gIGNvbnN0IHZlcnRpY2VzID0gW107XG4gIG9mZnNldHMuZm9yRWFjaCh4eU9mZnNldHMgPT4ge1xuICAgIHh5T2Zmc2V0cy5mb3JFYWNoKG9mZnNldCA9PiB7XG4gICAgICBjb25zdCB4ID0gcmVmVmVydGV4WCArIG9mZnNldFswXSAqIGNlbGxTaXplWzBdO1xuICAgICAgY29uc3QgeSA9IHJlZlZlcnRleFkgKyBvZmZzZXRbMV0gKiBjZWxsU2l6ZVsxXTtcbiAgICAgIHZlcnRpY2VzLnB1c2goW3gsIHldKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHZlcnRpY2VzO1xufVxuIl19