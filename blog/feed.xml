<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2017-03-28T15:12:25-07:00</updated><id>http://localhost:4000/blog/</id><title type="html">Deck.gl Blog</title><subtitle>A blog for deck.gl: WebGL-powered data visualization</subtitle><author><name>Uber</name></author><entry><title type="html">Wind Map</title><link href="http://localhost:4000/blog/2017/wind" rel="alternate" type="text/html" title="Wind Map" /><published>2017-03-13T00:00:00-07:00</published><updated>2017-03-13T00:00:00-07:00</updated><id>http://localhost:4000/blog/2017/wind</id><content type="html" xml:base="http://localhost:4000/blog/2017/wind">&lt;p&gt;A few weeks ago I set on trying out new WebGL 2.0 features with deck.gl. WebGL 2.0 brings plenty of new goodies to be used for game development, creative coding and data visualization like instancing, floating-point textures, transform feedback, multiple render targets, and more. With this in mind, and inspired by the work of Cameron Beccario, Viegas and Wattenberg and NASA I created a WebGL 2.0 wind map demo using deck.gl.&lt;/p&gt;

&lt;p&gt;This interactive demo enables you to change the map’s perspective by using cmd + drag; toggle between vector field and particle layers on the left panel, and use the slider to change the time of day to see wind change for a 72 hour period.&lt;/p&gt;

&lt;h2 id=&quot;some-interesting-insights&quot;&gt;Some interesting insights&lt;/h2&gt;
&lt;p&gt;The picture below shows wind speed near Mount Washington, which has the fastest winds in the US.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;../img/wind1.gif&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Something interesting to look at as well are the wind corridors being formed in Florida at specific times.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;../img/wind2.png&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;under-the-hood&quot;&gt;Under the hood&lt;/h2&gt;
&lt;p&gt;There are thousands of stations that capture wind speed, orientation and temperature with different time granularity. If you turn all layers off you’ll see yellow dots that represent each one of the stations we’re getting data from.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;../img/wind3.gif&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;For this example though one of the challenges was to be able to get a uniform distribution of wind speed, direction and temperature that could be sampled at any point of the map, not simply at each station. In order to do this we created a Delaunay tessellation for the stations, and then rendered the mesh to a floating-point texture, to get GPU-interpolated values into an image. In this case we map wind direction to the red channel, wind speed to green, temperature to blue and elevation to alpha.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;../img/wind4.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;You can see the Delaunay mesh rendered to an image below.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;../img/wind5.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;The next step was to use instancing to create a regular vector field layer. For this we created tetrahedron instances to serve as arrows and used the texture above to set their orientation, color and size. If you use the slider on the left you’ll also see that there’s GPU interpolation. Although we sample data every hour, we interpolate between the textures so we can estimate the values at each minute. Since we already had the Delaunay model we also used that to give an approximation of the elevation in the US:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;../img/wind6.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Finally we used transform feedback, which enables us to only use the vertex shader for data processing and updating every particle’s position in real-time. We throw a random sample of particles (~1M) that get updated by the texture data, and then render those on the screen. Every particle has a TTL (time-to-live); when the TTL expires it gets repositioned at a random location on the map. Blending reveals where the biggest concentration of particles are.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;../img/wind7.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;And that’s it! Three custom layers built with deck.gl to bring this wind map to life. Check out the example here and feel free to provide feedback!&lt;/p&gt;</content><author><name>{&quot;display_name&quot;=&gt;&quot;Nicolas Belmonte&quot;, &quot;github_username&quot;=&gt;&quot;philogb&quot;, &quot;email&quot;=&gt;&quot;nico@uber.com&quot;}</name><email>nico@uber.com</email></author><category term="Vis" /><category term="WebGL" /><summary type="html">A few weeks ago I set on trying out new WebGL 2.0 features with deck.gl. WebGL 2.0 brings plenty of new goodies to be used for game development, creative coding and data visualization like instancing, floating-point textures, transform feedback, multiple render targets, and more. With this in mind, and inspired by the work of Cameron Beccario, Viegas and Wattenberg and NASA I created a WebGL 2.0 wind map demo using deck.gl.</summary></entry><entry><title type="html">Hello World - deck.gl</title><link href="http://localhost:4000/blog/2017/hello-world" rel="alternate" type="text/html" title="Hello World - deck.gl" /><published>2017-03-06T00:00:00-08:00</published><updated>2017-03-06T00:00:00-08:00</updated><id>http://localhost:4000/blog/2017/hello-world</id><content type="html" xml:base="http://localhost:4000/blog/2017/hello-world">&lt;p&gt;&lt;img src=&quot;../img/header-bg.jpg&quot; alt=&quot;deck.gl&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;deck.gl is designed to make visualization of large data sets simple.
It enables users to quickly get impressive visual results with limited effort
through composition of existing layers, while offering a complete architecture
for packaging advanced WebGL based visualizations as reusable JavaScript
layers.&lt;/p&gt;

&lt;h2 id=&quot;brief-overview&quot;&gt;Brief Overview&lt;/h2&gt;

&lt;p&gt;The basic idea of using deck.gl is to render a stack of visual overlays,
usually (but not always) over maps.&lt;/p&gt;

&lt;p&gt;To make this simple concept work, deck.gl handles a number of challenges:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Handling of large data sets and performant updates&lt;/li&gt;
  &lt;li&gt;Interactive event handling such as picking&lt;/li&gt;
  &lt;li&gt;Cartographic Projections and integration with underlying map&lt;/li&gt;
  &lt;li&gt;Selection of proven, well-tested layers&lt;/li&gt;
  &lt;li&gt;Ability for the user to create new layers and customize existing layers&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ecosystem&quot;&gt;Ecosystem&lt;/h2&gt;

&lt;p&gt;deck.gl has been developed in parallel with a number of companion modules:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://uber.github.io/luma.gl/#/&quot;&gt;luma.gl&lt;/a&gt; -
A general purpose WebGL library designed to be interoperable both with the
raw WebGL API and (as far as possible) with other WebGL libraries.
In particular, luma.gl does not claim ownership of the WebGL context, and can
work with any supplied context, including contexts created by the application
or other WebGL libraries.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://uber.github.io/react-map-gl/#/&quot;&gt;react-map-gl&lt;/a&gt; - A React wrapper
around Mapbox GL which works seamlessly with deck.gl.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In addition, in the future we hope to publish additional deck.gl layers and
layer packages as separate modules.&lt;/p&gt;

&lt;h2 id=&quot;learning-deckgl&quot;&gt;Learning deck.gl&lt;/h2&gt;

&lt;p&gt;How you approach learning deck.gl will probably depend on your previous
knowledge and how you want to use it.&lt;/p&gt;

&lt;p&gt;Learning the layer props, and reading the basic articles in the deck.gl
documentation should of course be the first step. But where do you go
after that?&lt;/p&gt;

&lt;h3 id=&quot;understanding-the-reactive-programming-model&quot;&gt;Understanding the Reactive Programming Model&lt;/h3&gt;

&lt;p&gt;deck.gl is designed according to the principles of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Reactive_programming&quot;&gt;Reactive Programming Model&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The key to writing good, performant deck.gl applications and layers
lies in understanding how to minimize updates and redundant calculations.&lt;/p&gt;

&lt;p&gt;It is important to understand the implications of the shallow equality
comparisons deck.gl performs on layer properties, and how this implies that
new data and property objects must only be created when the underlying
data actually changes in order to prevent unnecessary updates.&lt;/p&gt;

&lt;p&gt;There is an impressive amount of information (documentation, blog posts,
educational videos, etc.) on the reactive programming paradigm in relation to
modern web frameworks such as React, Flux and Redux. Where to start depends
mostly on your application architecture choices.&lt;/p&gt;

&lt;h3 id=&quot;understanding-webgl&quot;&gt;Understanding WebGL&lt;/h3&gt;

&lt;p&gt;This is only needed if you want to create custom layers in deck.gl.
Note that while trying out a new ambitious rendering approach for a
new layer will likely require deeper knowledge, it is often possible to modify
or extend existing deck.gl layers (including modifying the shader code) with
a surprisingly limited amount of WebGL knowledge.&lt;/p&gt;

&lt;p&gt;There are many web resources for learning WebGL. The
&lt;a href=&quot;https://uber.github.io/luma.gl/#/&quot;&gt;luma.gl&lt;/a&gt; documentation
can be a starting point.&lt;/p&gt;</content><author><name>{&quot;display_name&quot;=&gt;&quot;Ib Green&quot;, &quot;github_username&quot;=&gt;&quot;ibgreen&quot;, &quot;email&quot;=&gt;&quot;ib@uber.com&quot;}</name><email>ib@uber.com</email></author><category term="WebGL" /><category term="React" /><summary type="html"></summary></entry></feed>