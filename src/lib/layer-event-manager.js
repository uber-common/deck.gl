import {log} from './utils';
import EventManager from '../utils/events/event-manager';

const noop = () => {};
const DEFAULT_OPTIONS = {
  pickingRadius: 0,
  onLayerClick: noop,
  onLayerHover: noop
};

export default class LayerEventManager {
  constructor(layerManager, eventTarget, options = {}) {
    this._onClick = this._onClick.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);
    this.eventHandlerMap = {
      click: this._onClick,
      pointermove: this._onPointerMove
    };

    this.layerManager = layerManager;
    this.eventManager = new EventManager(eventTarget);

    this.options = {};
    this.set(options);
  }

  set(options = {}) {
    Object.keys(DEFAULT_OPTIONS).forEach(k => {
      this.options[k] = options[k] !== 'undefined' ? options[k] : DEFAULT_OPTIONS[k];
    });
    this._validateEventHandling();
  }

  addEventListeners(eventNames) {
    const events = {};
    eventNames.forEach(name => {
      if (this.eventHandlerMap[name]) {
        events[name] = this.eventHandlerMap[name];
      } else {
        log(1, `Event "${name}" is not supported.`);
      }
    });
    this.eventManager.on(events);
  }

  removeEventListeners(element, eventNames) {
    // TODO
  }

  _validateEventHandling() {
    // Check if a deck-level mouse event has been specified
    // and that at least one of the layers in the deck is pickable
    if ([
      this.options.onLayerClick,
      this.options.onLayerHover
    ].some(handler => handler !== noop)) {
      const {layers} = this.layerManager;
      if (layers.length && !layers.some(l => l.props.pickable)) {
        log.once(1,
          'You have supplied a mouse event handler but none of your layers set the `pickable` flag.'
        );
      }
    }
  }

  /**
   * Route click events to layers.
   * `pickLayer` will call the `onClick` prop of any picked layer,
   * and `onLayerClick` is called directly from here
   * with any picking info generated by `pickLayer`.
   */
  _onClick(event) {
    const pos = event.offsetCenter;
    if (!pos) {
      return;
    }
    const radius = this.pickingRadius;
    const selectedInfos = this.layerManager.pickLayer({x: pos.x, y: pos.y, radius, mode: 'click'});
    if (selectedInfos.length) {
      const firstInfo = selectedInfos.find(info => info.index >= 0);
      // Event.srcEvent holds the original Event object
      this.options.onLayerClick(firstInfo, selectedInfos, event.srcEvent);
    }
  }

  /**
   * Route click events to layers.
   * `pickLayer` will call the `onHover` prop of any picked layer,
   * and `onLayerHover` is called directly from here
   * with any picking info generated by `pickLayer`.
   */
  _onPointerMove(event) {
    const pos = event.offsetCenter;
    // TODO: consider using this.eventManager.element size instead of layerManager.context
    // but do so in a way that doesn't cause reflow (e.g. `offsetWidth/Height`).
    // maybe the event object offers offsetCenter as a 0<>1 value as well?
    // since it's already doing size calculations...
    const {width, height} = this.layerManager.context.viewport;
    if (!pos || pos.x < 0 || pos.y < 0 || pos.x > width || pos.y > height) {
      // Check if pointer is inside the canvas
      return;
    }
    const radius = this.pickingRadius;
    const selectedInfos = this.layerManager.pickLayer({x: pos.x, y: pos.y, radius, mode: 'hover'});
    if (selectedInfos.length) {
      const firstInfo = selectedInfos.find(info => info.index >= 0);
      // Event.srcEvent holds the original Event object
      this.options.onLayerHover(firstInfo, selectedInfos, event.srcEvent);
    }
  }
}
