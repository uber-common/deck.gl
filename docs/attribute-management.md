# Attribute Management

Automated attribute generation and management. Suitable when a set of
vertex shader attributes are generated by iteration over a data array,
and updates to these attributes are needed either when the data itself
changes, or when other data relevant to the calculations change.

- First the application registers descriptions of its dynamic vertex
  attributes using AttributeManager.add().
- Then, when any change that affects attributes is detected by the
  application, the app will call AttributeManager.invalidate().
- Finally before it renders, it calls AttributeManager.update() to
  ensure that attributes are automatically rebuilt if anything has been
  invalidated.

The application provided update functions describe how attributes
should be updated from a data array and are expected to traverse
that data array (or iterable) and fill in the attribute's typed array.

Note that the attribute manager intentionally does not do advanced
change detection, but instead makes it easy to build such detection
by offering the ability to "invalidate" each attribute separately.

Summary:
- keeps track of valid state for each attribute
- auto reallocates attributes when needed
- auto updates attributes with registered updater functions
- allows overriding with application supplied buffers

Limitations:
- There are currently no provisions for only invalidating a range of
  indices in an attribute.


## Notes on WebGL buffer management

deck.gl Layers were designed with data flow architectures like React in mind.
The challenge is of course that in the react model, every change to application
state causes a full rerender. The rendering callbacks are then supposed to
detect what changes were made a limit rerendering as appropriate. When you
have a couple of 100K element WebGL buffers to update, this can become quite
expensive unless change detection is well managed.


### Data Management using automatic Buffer updates

The layer will expect each object to provide a number of "attributes" that it
can use to set the GL buffers. By default, the layer will look for these
attributes to be available as fields directly on the objects during iteration
over the supplied data set. To gain more control of attribute access and/or
to do on-the-fly calculation of attributes.


### Manual Buffer Management

For ultimate performance and control of updates, the application can do its
own management of the glbuffers. Each Layer can accept buffers directly as
props.

**Note:** The application can provide some buffers and let others be managed
by the layer. As an example management of the `instancePickingColors` buffer is
normally left to the layer.

**Note**: A layer only renders when a property change is detected. For
performance reasons, property change detection uses shallow compare,
which means that mutating an element inside a buffer or a mutable data array
does not register as a property change, and thus does not trigger a rerender.
To force trigger a render after mutating buffers, simply increment the
`renderCount` property. To force trigger a buffer update after mutating data,
increment the `updateCount` property.


## class AttributeManager
@classdesc
Automated attribute generation and management. Suitable when a set of
vertex shader attributes are generated by iteration over a data array,
and updates to these attributes are needed either when the data itself
changes, or when other data relevant to the calculations change.

- First the application registers descriptions of its dynamic vertex
  attributes using AttributeManager.add().
- Then, when any change that affects attributes is detected by the
  application, the app will call AttributeManager.invalidate().
- Finally before it renders, it calls AttributeManager.update() to
  ensure that attributes are automatically rebuilt if anything has been
  invalidated.

The application provided update functions describe how attributes
should be updated from a data array and are expected to traverse
that data array (or iterable) and fill in the attribute's typed array.

Note that the attribute manager intentionally does not do advanced
change detection, but instead makes it easy to build such detection
by offering the ability to "invalidate" each attribute separately.

Summary:
- keeps track of valid state for each attribute
- auto reallocates attributes when needed
- auto updates attributes with registered updater functions
- allows overriding with application supplied buffers

Limitations:
- There are currently no provisions for only invalidating a range of
  indices in an attribute.


### Constructor
constructor({
  id = 'attribute-manager',
  ...otherProps
} = {}) {

@class
@param {Object} [props]
@param {String} [props.id] - identifier (for debugging)
    this.id = id;
    this.attributes = {};
    this.allocedInstances = -1;
    this.needsRedraw = true;
    this.userData = {};

    this.onUpdateStart = noop;
    this.onUpdateEnd = noop;
    this.onLog = this._defaultLog;

    // For debugging sanity, prevent uninitialized members
    Object.seal(this);
  }


### AttributeManager.add(attributes, updaters = {}

Adds attributes
Takes a map of attribute descriptor objects
- keys are attribute names
- values are objects with attribute fields

attribute.size - number of elements per object
attribute.updater - number of elements
attribute.instanced=0 - is this is an instanced attribute (a.k.a. divisor)
attribute.noAlloc=false - if this attribute should not be allocated

@example
attributeManager.add({
  positions: {size: 2, update: calculatePositions}
  colors: {size: 3, update: calculateColors}
});

@param {Object} attributes - attribute map (see above)
@param {Object} updaters - separate map of update functions (deprecated)


### AttributeManager.  update({
    data,
    numInstances,
    buffers = {},
    props = {},
    context = {},
    ...opts
  } = {}) {


Ensure all attribute buffers are updated from props or data.

Note: Any preallocated buffers in "buffers" matching registered attribute
names will be used. No update will happen in this case.
Note: Calls onUpdateStart and onUpdateEnd log callbacks before and after.

@param {Object} opts - options
@param {Object} opts.data - data (iterable object)
@param {Object} opts.numInstances - count of data
@param {Object} opts.buffers = {} - pre-allocated buffers
@param {Object} opts.props - passed to updaters
@param {Object} opts.context - Used as "this" context for updaters


### AttributeManager.
  setLogFunctions({
    onLog,
    onUpdateStart,
    onUpdateEnd
  } = {}) {

Sets log functions to help trace or time attribute updates.
Default logging uses luma logger.

Note that the app may not be in control of when update is called,
so hooks are provided for update start and end.

@param {Object} [opts]
@param {String} [opts.onLog=] - called to print
@param {String} [opts.onUpdateStart=] - called before update() starts
@param {String} [opts.onUpdateEnd=] - called after update() ends
    this.onLog = onLog !== undefined ? onLog : this.onLog;
    this.onUpdateStart =
      onUpdateStart !== undefined ? onUpdateStart : this.onUpdateStart;
    this.onUpdateEnd =
      onUpdateEnd !== undefined ? onUpdateEnd : this.onUpdateEnd;
  }


### getAttributes() {

Returns all attribute descriptors
Note: Format matches luma.gl Model/Program.setAttributes()
@return {Object} attributes - descriptors


### getChangedAttributes({clearChangedFlags = false}) {

Returns changed attribute descriptors
This indicates which WebGLBuggers need to be updated
@return {Object} attributes - descriptors


### getNeedsRedraw({clearRedrawFlags = false} = {}) {

Returns the redraw flag, optionally clearing it.
Redraw flag will be set if any attributes attributes changed since
flag was last cleared.

@param {Object} [opts]
@param {String} [opts.clearRedrawFlags=false] - whether to clear the flag
@return {Boolean} - whether a redraw is needed.


### setNeedsRedraw(redraw = true) {

Sets the redraw flag.
@param {Boolean} redraw=true
@return {AttributeManager} - for chaining


###  _checkExternalBuffers(bufferMap = {}, opts = {}) {
  // Checks that any attribute buffers in props are valid
  // Note: This is just to help app catch mistakes


###  _setExternalBuffers(bufferMap) {
  // Set the buffers for the supplied attributes
  // Update attribute buffers from any attributes in props
  // Detach any previously set buffers, marking all
  // Attributes for auto allocation
  /* eslint-disable max-statements */


### _analyzeBuffers({numInstances}) {
  /* Checks that typed arrays for attributes are big enough
sets alloc flag if not
@return {Boolean} whether any updates are needed


### _updateBuffers({numInstances, data, props, context}) {
@private
Calls update on any buffers that need update
TODO? - If app supplied all attributes, no need to iterate over data

@param {Object} opts - options
@param {Object} opts.data - data (iterable object)
@param {Object} opts.numInstances - count of data
@param {Object} opts.buffers = {} - pre-allocated buffers
@param {Object} opts.props - passed to updaters
@param {Object} opts.context - Used as "this" context for updaters
  /* eslint-disable max-statements */
